---
last_update: { author: "Sagar Vemala" }
---

# Overview

WaveMaker provides a robust, developer-friendly approach to working with databases. When an application is connected to a database, WaveMaker introspects the complete schema and automatically generates a standardized API layer with CRUD operations.

This approach combines visual database connectivity and management with full access to the generated source code—enabling rapid development without sacrificing customization or control.

---

## Database Support and Connectivity 

WaveMaker uses **[JDBC](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/)** for all relational database connections. Developers configure the connection details, while WaveMaker manages the connection lifecycle internally.

### Supported Relational Databases
WaveMaker supports the following databases out of the box:

- MariaDB  
- MySQL  
- PostgreSQL  
- Oracle  
- SQL Server  
- Azure SQL Database  
- IBM DB2  
- HSQLDB  

These databases can be connected directly from the **Database Workspace**.

If a database is not listed above, it can still be used as long as a compatible JDBC driver is available. Developers can add the required driver and configure the connection manually.

### NoSQL Support

In addition to relational databases, WaveMaker supports NoSQL databases through the **Connector Framework**. NoSQL data sources are exposed as APIs and can be consumed in applications just like any other backend service.

Once a database connection is established, WaveMaker introspects the schema and makes database objects available for API generation and application development.

---

## Database Workspace

WaveMaker provides a dedicated **Database Workspace** that serves as the central hub for all database-related activities.

From the Database Workspace, you can:

- Connect to databases  
- Browse schemas, tables, views, and procedures  
- Import database objects  
- Automatically generate APIs  

A short video in this section walks through the Database Workspace UI and demonstrates how developers can visually interact with their databases.

Learn more: [Database Explorer](../../../studio/workspaces/database-explorer.mdx)

---

## Auto-Generated APIs: Standard CRUD

Once a database is connected, WaveMaker automatically generates CRUD APIs for selected tables and views. These APIs are managed and exposed through the  **[API Explorer](../../../studio/workspaces/api-explorer.mdx)**

#### Generated APIs:
- Follow REST conventions  
- Support pagination, sorting, and filtering  
- Include commonly used APIs such as `getByUniqueKey`, `ExporttoExcel`, `Aggregated data APIs` and many more
- Are production-ready and consumable by client applications  

All generated APIs are visualized using a standard **Swagger (OpenAPI)** interface within the API Workspace.

#### From Swagger UI, developers can:
- Browse available endpoints and data models  
- Execute and test APIs directly  
- Validate request/response contracts  

This allows teams to finalize and validate backend APIs independently before building the UI.

Learn more: [API Explorer](../../../studio/workspaces/api-explorer.mdx)

---

## Extended APIs: Queries and Stored Procedures

Beyond standard CRUD operations, WaveMaker allows developers to extend the API layer using database-specific logic through **custom SQL queries** and **stored procedures**. These extended APIs are managed from the API Workspace.

#### Custom SQL Queries
Developers can define custom SQL queries to handle advanced data access needs such as:
- Complex joins  
- Aggregations  
- Filters and projections  

From the API Workspace, developers can:
- Create and edit SQL queries  
- Execute and test queries against the database  
- Save validated queries for reuse  

For each saved query, WaveMaker automatically generates a corresponding API, which can be invoked like any other backend service.

#### Stored Procedures
WaveMaker also supports invoking existing stored procedures and functions defined in the database. This enables execution of database-side business logic without duplicating it in the application layer.

Developers can:
- Select stored procedures from the database  
- Map input and output parameters  
- Test execution directly from the workspace  

WaveMaker generates REST APIs for these procedures, allowing applications to invoke database logic in a consistent and standardized way.

Both queries and stored procedures are exposed in the same manner as generated CRUD services, ensuring uniform access patterns while keeping business logic centralized at the database level.

Learn more: [Queries and Procedures](./queries-and-procedures.md)

---

## Source Code and Control

WaveMaker gnerated code is not black boxed. All generated code is human-readable, standards-based source code that follows well-defined architectural best practices. The generated code is designed to be easily understood, extended, and maintained by developers, ensuring long-term flexibility and control.

- WaveMaker generates **human-readable, standards-based code**
- Follows proven architectural patterns using **Java, Spring, and Hibernate/JPA**
- Clear separation of concerns across controller, service, and data layers
- Developers can inspect, understand, and extend the generated code
- Custom logic can be added safely without impacting platform upgrades
- Full control for advanced enterprise and customization needs

Learn more: [WaveMaker Generated Backend Architecture](./orm-artifacts.md)

---

## Related Documentation

- [ORM Artifacts](./orm-artifacts.md) – Understanding generated ORM artifacts  
- [Queries and Procedures](./queries-and-procedures.md) – Custom queries and stored procedures
